<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深度学习笔记</title>
    <link href="/2026/01/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2026/01/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>封面为BP算法可视化，来自<a href="https://towardsdatascience.com/understanding-backpropagation-abcc509ca9d0/">Understanding Backpropagation | Towards Data Science</a>，作者<a href="https://towardsdatascience.com/author/brent-scarff/">Brent Scarff</a>。</p><h1 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h1><h4 id="1、讲一下深度学习都有哪些组成，以及每一部分你的理解"><a href="#1、讲一下深度学习都有哪些组成，以及每一部分你的理解" class="headerlink" title="1、讲一下深度学习都有哪些组成，以及每一部分你的理解?"></a>1、讲一下深度学习都有哪些组成，以及每一部分你的理解?</h4><h4 id="2、为什么神经网络中必须使用激活函数，你都知道哪些激活函数"><a href="#2、为什么神经网络中必须使用激活函数，你都知道哪些激活函数" class="headerlink" title="2、为什么神经网络中必须使用激活函数，你都知道哪些激活函数?"></a>2、为什么神经网络中必须使用激活函数，你都知道哪些激活函数?</h4><h4 id="3、输出层的激活函数怎么选择"><a href="#3、输出层的激活函数怎么选择" class="headerlink" title="3、输出层的激活函数怎么选择?"></a>3、输出层的激活函数怎么选择?</h4><h4 id="4、梯度是什么-链式求导法则"><a href="#4、梯度是什么-链式求导法则" class="headerlink" title="4、梯度是什么?链式求导法则?"></a>4、梯度是什么?链式求导法则?</h4><h4 id="5、常见的优化器有哪些-区别"><a href="#5、常见的优化器有哪些-区别" class="headerlink" title="5、常见的优化器有哪些?区别?"></a>5、常见的优化器有哪些?区别?</h4><h4 id="6、你了解的损失函数有哪些-它们的公式以及应用场景"><a href="#6、你了解的损失函数有哪些-它们的公式以及应用场景" class="headerlink" title="6、你了解的损失函数有哪些?它们的公式以及应用场景?"></a>6、你了解的损失函数有哪些?它们的公式以及应用场景?</h4><h4 id="7、神经网络训练中的超参数有哪些"><a href="#7、神经网络训练中的超参数有哪些" class="headerlink" title="7、神经网络训练中的超参数有哪些?"></a>7、神经网络训练中的超参数有哪些?</h4><h4 id="8、你了解哪些常用的模型评估指标"><a href="#8、你了解哪些常用的模型评估指标" class="headerlink" title="8、你了解哪些常用的模型评估指标?"></a>8、你了解哪些常用的模型评估指标?</h4><h4 id="9、什么是过拟合和欠拟合-解决方法有哪些"><a href="#9、什么是过拟合和欠拟合-解决方法有哪些" class="headerlink" title="9、什么是过拟合和欠拟合?解决方法有哪些?"></a>9、什么是过拟合和欠拟合?解决方法有哪些?</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>机试备考规划P1：一周筑基</title>
    <link href="/2026/01/27/%E6%9C%BA%E8%AF%95%E5%A4%87%E8%80%83%E8%A7%84%E5%88%92P1%EF%BC%9A%E4%B8%80%E5%91%A8%E7%AD%91%E5%9F%BA/"/>
    <url>/2026/01/27/%E6%9C%BA%E8%AF%95%E5%A4%87%E8%80%83%E8%A7%84%E5%88%92P1%EF%BC%9A%E4%B8%80%E5%91%A8%E7%AD%91%E5%9F%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用元宝DeepSeek盘了一下代码随想录的机试营题目，拟定了一个刷题计划。</p><p>这周刷完基础题，下周开始二叉树。树、dp和图才是重点。</p><h4 id="练习模式"><a href="#练习模式" class="headerlink" title="练习模式"></a>练习模式</h4><ul><li><strong>ACM 模式</strong>：机试规定模式，自己写输入输出逻辑。适合数组、字符串的模拟题、规则题。</li><li><strong>核心代码模式</strong>：只需实现核心算法。适合链表、树等数据结构操作题，快速验证算法思路。</li></ul><p>对于复杂数据输入题，前期可先用核心代码模式攻坚算法思想，后期再找 ACM 模式题目巩固。</p><h4 id="练习平台"><a href="#练习平台" class="headerlink" title="练习平台"></a>练习平台</h4><ul><li><strong>卡码网（KamAc.com）</strong>：专门针对 ACM 模式，题目描述和IO格式与机试高度一致。</li><li><strong>LeetCode</strong>：默认核心模式，有一些比赛和题目支持 ACM 模式。</li></ul><hr><h1 id="一周基础攻坚计划"><a href="#一周基础攻坚计划" class="headerlink" title="一周基础攻坚计划"></a>一周基础攻坚计划</h1><p>每天分配4小时，题目优先级依次为🌟P0、✅P1、➖P2。</p><table><thead><tr><th>天数</th><th>核心模块与重点题目</th><th>练习模式</th><th>每日学习焦点与技巧</th></tr></thead><tbody><tr><td><strong>Day 1</strong><em>数组基础</em></td><td>🌟<strong>704. 二分查找</strong></td><td>核心代码模式</td><td>重点攻克二分查找的<strong>区间定义</strong>（左闭右闭&#x2F;左闭右开），确保写对。</td></tr><tr><td></td><td>🌟<strong>27. 移除元素</strong>（双指针法）</td><td>核心代码模式</td><td><strong>主题：双指针相向而行</strong>。</td></tr><tr><td></td><td>✅<strong>977. 有序数组的平方</strong></td><td>核心代码模式</td><td>双指针的经典应用，为后续更复杂的双指针题打基础。IO简单。</td></tr><tr><td></td><td>✅<strong>54. 替换数字</strong>（字符串）</td><td><strong>ACM 模式</strong></td><td>字符串入门，巩固数组操作思想。机试高频题型。</td></tr><tr><td><strong>Day 2</strong><em>数组进阶</em></td><td>🌟<strong>209. 长度最小的子数组</strong>（滑动窗口）</td><td>核心代码模式</td><td><strong>主题：滑动窗口与字符串反转</strong>。IO 简单，集中精力理解窗口收缩与扩张的逻辑。</td></tr><tr><td></td><td>🌟<strong>区间和</strong>（前缀和思想）</td><td><strong>ACM 模式</strong></td><td>前缀和是重要优化思想。151 题综合性很强，可能耗时较多。</td></tr><tr><td></td><td>🌟<strong>151. 翻转字符串里的单词</strong>（字符串）</td><td><strong>ACM 模式</strong></td><td>可与 344 题结合学习，理解局部与整体反转。</td></tr><tr><td></td><td>🌟<strong>344. 反转字符串</strong>（字符串）</td><td>核心代码模式</td><td>IO 简单，效率优先。</td></tr><tr><td><strong>Day 3</strong><em>链表核心</em></td><td>🌟<strong>203. 移除链表元素</strong>（虚拟头结点）</td><td>核心代码模式</td><td><strong>主题：虚拟头结点与双指针</strong>。学会虚拟头结点，一劳永逸。</td></tr><tr><td></td><td>🌟<strong>206. 反转链表</strong></td><td>核心代码模式</td><td>-</td></tr><tr><td></td><td>🌟<strong>19. 删除链表的倒数第 N 个节点</strong></td><td>核心代码模式</td><td>快慢指针的典范。</td></tr><tr><td></td><td>✅<strong>24. 两两交换链表中的节点</strong></td><td>核心代码模式</td><td>综合练习，画图理解指针变换。</td></tr><tr><td><strong>Day 4</strong><em>哈希表</em></td><td>🌟<strong>242. 有效的字母异位词</strong></td><td><strong>ACM 模式</strong></td><td><strong>主题：哈希表的映射与优化</strong>。掌握数组作为哈希表的场景。</td></tr><tr><td></td><td>🌟<strong>1. 两数之和</strong></td><td><strong>ACM 模式</strong></td><td>掌握<code>map</code>作为哈希表的场景。</td></tr><tr><td></td><td>✅<strong>454. 四数相加 II</strong></td><td>核心代码模式</td><td>IO复杂，重点理解”分组 + 哈希”的优化思想。</td></tr><tr><td></td><td>✅<strong>15. 三数之和</strong>（<strong>重点学双指针法</strong>）</td><td>核心代码模式</td><td><strong>切记跳过哈希法</strong>。IO复杂，重点掌握“排序 + 双指针 + 去重”算法组合。</td></tr><tr><td><strong>Day 5</strong><em>栈与队列</em></td><td>🌟<strong>20. 有效的括号</strong></td><td><strong>ACM 模式</strong></td><td><strong>主题：栈的经典应用</strong>。必须快速写对。</td></tr><tr><td></td><td>✅<strong>150. 逆波兰表达式求值</strong></td><td><strong>ACM 模式</strong></td><td>深刻理解栈”处理对称性、记录历史”的能力。</td></tr><tr><td></td><td>✅<strong>1047. 删除字符串中的所有相邻重复项</strong></td><td><strong>ACM 模式</strong></td><td>同上。</td></tr><tr><td></td><td>➖<strong>232. 用栈实现队列</strong>（<strong>理解思路即可</strong>）</td><td>核心代码模式</td><td>理解思路即可，节省时间。</td></tr><tr><td><strong>Day 6</strong><em>综合与难点</em></td><td>🌟<strong>239. 滑动窗口最大值</strong>（<strong>难点</strong>）</td><td><strong>ACM 模式</strong></td><td><strong>主题：攻克高频难点</strong>。主攻前两个有难度的 P0 题。务必理解思路。</td></tr><tr><td></td><td>🌟<strong>347. 前 K 个高频元素</strong></td><td><strong>ACM 模式</strong></td><td>务必理解思路。</td></tr><tr><td></td><td>✅<strong>160. 链表相交</strong></td><td>核心代码模式</td><td>直接看巧妙解法。</td></tr><tr><td></td><td>🌟<strong>541. 反转字符串 II</strong></td><td><strong>ACM 模式</strong></td><td>作为调剂，巩固字符串规则处理。</td></tr><tr><td><strong>Day 7</strong><em>复习与收尾</em></td><td>✅<strong>59. 螺旋矩阵 II</strong></td><td><strong>ACM 模式</strong></td><td><strong>主题：模拟题与巩固</strong>。训练模拟和边界处理能力。</td></tr><tr><td></td><td>✅<strong>55. 右旋转字符串</strong></td><td><strong>ACM 模式</strong></td><td>学习反转技巧的灵活运用。</td></tr><tr><td></td><td><strong>复习本周所有 P0 题目的思路</strong></td><td>-</td><td>回顾 P0 题目的核心思想。</td></tr><tr><td></td><td><strong>尝试用 5 分钟快速默写”206. 反转链表”和”20. 有效的括号”</strong></td><td>-</td><td>-</td></tr></tbody></table><hr><h4 id="💡-元宝DS提的建议"><a href="#💡-元宝DS提的建议" class="headerlink" title="💡 元宝DS提的建议"></a>💡 元宝DS提的建议</h4><ol><li><strong>时间分配建议</strong>：如果 P0 题目卡住超过 1 小时，不要死磕，直接看题解理解思路，然后自己复现，保证整体进度。如果 P1 题目时间不够，可以快速阅读题解，理解核心思想。</li><li><strong>画图分析</strong>：对于链表、双指针、滑动窗口等题目，画图模拟是理解逻辑最有效的方法。</li><li><strong>总结模板与思想</strong>：每做完一种<strong>主题</strong>的题目（如二分查找、滑动窗口），停下来总结一下通用解法和注意事项，形成自己的解题模板。</li><li><strong>为树做准备</strong>：本周为树打基础的算法有<strong>递归</strong>（反转链表等）、<strong>栈</strong>（二叉树迭代遍历）、<strong>队列</strong>（二叉树层序遍历）、<strong>双指针</strong>。练习时有意识想想这个技巧在树里怎么用。</li></ol><hr><h1 id="模板汇总"><a href="#模板汇总" class="headerlink" title="模板汇总"></a>模板汇总</h1><p>每种主题题目的模板解法，可以全文搜索关键词。</p><ul><li>数组：概念定义、双指针法、后序处理、滑动窗口、前缀和。</li><li>链表：</li><li>哈希表：</li><li>字符串：</li><li>栈和队列：</li></ul><h1 id="Day-1-数组基础"><a href="#Day-1-数组基础" class="headerlink" title="Day 1 数组基础"></a>Day 1 数组基础</h1><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p>参考：<a href="https://leetcode.cn/problems/binary-search">力扣题目链接</a>、<a href="https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF">704. 二分查找 | 代码随想录</a>。</p><p>关键词：开闭区间，概念定义</p><h4 id="搜索区间"><a href="#搜索区间" class="headerlink" title="搜索区间"></a>搜索区间</h4><p>二分法的每一步搜索，都被限制在一个由<strong>端点参数</strong> <code>left</code> 与 <code>right</code> 标定的<strong>区间</strong>里。然而，描述区间还需要一个属性：<strong>开闭规则</strong>。它无法在函数中显式给出，因此常被忽视，但直接关系到边界条件写法。</p><p>一个完整的<strong>区间定义</strong>由端点参数与开闭规则组成，是二分搜索中的循环不变量。遵守循环不变量原则，就是提前定义好不变的概念，并在编写循环、边界条件时始终遵守概念。</p><h4 id="区间定义"><a href="#区间定义" class="headerlink" title="区间定义"></a>区间定义</h4><p>二分搜索区间的常见定义：<strong>左闭右闭</strong> <code>[left, right]</code> 和<strong>左闭右开</strong> <code>[left, right)</code> ，关系到两个边界条件：<code>while (left ❓ right)</code> 和 <code>if (nums[mid] &gt; target) right == ❓</code> 的写法。</p><p>两个条件本质在问：是否允许左右端点相等、是否允许右端点在区间外。从区间定义出发思考，都很容易回答。</p><p>两种定义一般都能解题，主要注意选一种定义就要遵守一套边界条件，不要搞混。下面列表简述。</p><table><thead><tr><th>区间定义 &#x2F; 边界条件</th><th><code>while (left ❓ right)</code></th><th><code>if (nums[mid] &gt; target) right == ❓</code></th></tr></thead><tbody><tr><td><code>[left, right]</code></td><td>填<code>&lt;=</code>。闭区间上<code>left == right</code>合法，例如<code>[1,1]</code>显然符合区间定义。</td><td>填<code>mid-1</code>。条件语句为真时，<code>mid</code>在区间外，但右端点<code>right</code>始终在区间内。因此，右端点只能再向左偏移一个单位。</td></tr><tr><td><code>[left, right)</code></td><td>填<code>&lt;</code>。开区间上<code>left == right</code>非法，例如<code>[1,1)</code>显然非法。</td><td>填<code>mid</code>。条件语句为真时，右端点<code>right</code>和<code>mid</code>都在区间外。因此，两者相等。</td></tr></tbody></table><p>注意传入数组只有一个元素时，不能用左闭右开区间定义。故左闭右闭是最保险的。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 区间1：[left, right]</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mid, left=<span class="hljs-number">0</span>, right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;                 <span class="hljs-comment">// 边界条件1❗️</span><br>            mid = left + (right - left) / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid<span class="hljs-number">-1</span>;                  <span class="hljs-comment">// 边界条件2❗️</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid<span class="hljs-number">+1</span>;                   <span class="hljs-comment">// left必在区间内，因此总是mid+1</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 区间2：[left, right)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mid, left=<span class="hljs-number">0</span>, right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;                  <span class="hljs-comment">// 边界条件1❗️</span><br>            mid = left + (right - left) / <span class="hljs-number">2</span>;    <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid;                    <span class="hljs-comment">// 边界条件2❗️</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>                left = mid<span class="hljs-number">+1</span>;                   <span class="hljs-comment">// left必在区间内，因此总是mid+1</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>参考：<a href="https://leetcode.cn/problems/remove-element">力扣题目链接</a>、<a href="https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html">27. 移除元素 | 代码随想录</a></p><p>关键词：双指针法、快慢指针</p><h4 id="数组基础"><a href="#数组基础" class="headerlink" title="数组基础"></a>数组基础</h4><p>地址空间连续，是数组良好性质的前提，不能被数组操作破坏。例如，不能单独删除数组中的某个元素，只能用后续元素覆盖。覆盖结束后，即可无视最后一个元素，视数组长度为n-1。</p><p>删除操作后，数组的<strong>大小</strong>(有效元素个数)改变，但<strong>容量</strong>(所占存储空间)不变。对应C++ vector容器即vec.erase()操作后，vec.size()改变，而vec.capacity()不变。</p><p>一种原地实现方法是<strong>循环覆盖</strong>，因此时间复杂度最低为O(n)，这就是vec.erase()的实现方法：快慢指针法。</p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>双指针法： <strong>通过两个指针，在一个 for 循环下遍历一次数组，完成两个 for 循环的工作。</strong></p><p>双指针有各种方向：从左往右、从外到内…… 本题是从左往右型，也叫<strong>快慢指针</strong>。</p><p>快慢指针更新一个新数组，<strong>由快指针排除指定元素，确保其不进入新数组</strong>。定义快慢指针为：</p><ul><li>快指针：<strong>寻找</strong>新数组元素的指针，指向下一个待检查元素。</li><li>慢指针：<strong>承接</strong>新数组元素的指针，指向新数组后一个位置。</li></ul><p>覆盖过程见代码随想录的动图，理解了快慢指针的定义就很直观了。</p><p><img src="https://file1.kamacoder.com/i/algo/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="27.移除元素-双指针法 | 代码随想录"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast != nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums[fast] == val) fast++;      <span class="hljs-comment">// 寻找新元素</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                nums[slow] = nums[fast];        <span class="hljs-comment">// 承接新元素</span><br>                fast++; slow++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a>977. 有序数组的平方</h3><p>参考：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array">力扣题目链接</a>、<a href="https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html">977.有序数组的平方 | 代码随想录</a></p><p>关键词：双指针法、归并</p><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><p>暴力法很好想，平方后快排，时间复杂度O(nlogn)，但没有利用数组的有序性。</p><p>数组平方后的有序性在于：绝对值小的在中间，大的在两边。因此可以定义双指针 <code>p</code> <code>q</code> 指向数组两端，辅助数组 <code>result</code> 通过指针 <code>r</code> ，从右往左逐个接收p、q指向的更大值。</p><p><img src="https://file1.kamacoder.com/i/algo/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="977.有序数组的平方 | 代码随想录"></p><p>思路类似归并排序，对于传入数组，以0为界分为左右两个有序子表，通过一次“边平方边归并”，生成一个更大的有序表。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>, q=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, r=q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (p &lt;= q) &#123;                                <span class="hljs-comment">// 不落下p==q的元素</span><br>            <span class="hljs-keyword">if</span> (nums[p]*nums[p] &gt; nums[q]*nums[q]) &#123;<br>                result[r--] = nums[p]*nums[p++];        <span class="hljs-comment">// p++：使用后即更新</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result[r--] = nums[q]*nums[q--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="54-替换数字"><a href="#54-替换数字" class="headerlink" title="54. 替换数字"></a>54. 替换数字</h3><p>参考：<a href="https://kamacoder.com/problempage.php?pid=1064">卡码网题目链接</a>、<a href="https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html">替换数字 | 代码随想录</a></p><p>关键词：双指针法，后序处理，概念定义</p><h4 id="后序处理"><a href="#后序处理" class="headerlink" title="后序处理"></a>后序处理</h4><p>本题主要体会：<strong>对于线性数据结构，填充或者删除，后序处理会高效的多</strong>。</p><p>后序处理，即<strong>预先给数组扩容到填充后的大小，然后从后向前进行操作</strong>。以本题为例，先扫描、扩容到数字→number后的大小，然后用双指针从后往前替换数字字符。<code>p</code>指向旧串末尾，<code>q</code>指向新串末尾。</p><p>高效在于：</p><ul><li>后序处理不用申请新数组。</li><li>前序处理每次填充要移动后续所有元素，时间复杂度O(n^2)；后序处理不用，时间复杂度O(n)。</li></ul><p>再次引用代码随想录的图解：</p><p><img src="https://file1.kamacoder.com/i/algo/20231030173058.png" alt="54. 替换数字 | 代码随想录"></p><p>注意<code>p</code>和<code>q</code>在循环初始，都是指向第一个<strong>未处理的</strong>元素。因此，每次循环开始前，<strong>指针指向下一个未处理元素的规则</strong>，是算法的循环不变量，即预先定义好的概念。</p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isNumber</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> i)</span> </span>&#123;<br><span class="hljs-comment">// 判断s[i]是否数字</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = <span class="hljs-string">&#x27;0&#x27;</span>; num &lt; <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">10</span>; num++) &#123;<br><span class="hljs-keyword">if</span> (s[i] == num) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">replaceNum</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> q)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) s[q--] = <span class="hljs-string">&#x27;r&#x27;</span>;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) s[q--] = <span class="hljs-string">&#x27;e&#x27;</span>;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) s[q--] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) s[q--] = <span class="hljs-string">&#x27;m&#x27;</span>;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) s[q--] = <span class="hljs-string">&#x27;u&#x27;</span>;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>) s[q--] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> q;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string s;<br>cin &gt;&gt; s;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>, p = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 保存数组原长度</span><br><br><span class="hljs-comment">// 统计s中数字个数，并扩容</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(s, i)) count++;<br>&#125;<br>s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-comment">// resize扩容串</span><br><br><span class="hljs-comment">// 双指针法后序处理</span><br><span class="hljs-type">int</span> q = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 数组现长度</span><br><span class="hljs-keyword">while</span> (p != q) &#123;<br><span class="hljs-comment">// 每次循环后，p和q都指向下一个待处理元素</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNumber</span>(s, p)) &#123;<br>q = <span class="hljs-built_in">replaceNum</span>(s, q);<br>p--;    <span class="hljs-comment">// 别在条件判断里p--</span><br>&#125;<br><span class="hljs-keyword">else</span> s[q--] = s[p--];<br>&#125;<br>cout &lt;&lt; s;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Day-2-数组进阶"><a href="#Day-2-数组进阶" class="headerlink" title="Day 2 数组进阶"></a>Day 2 数组进阶</h1><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>参考：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣题目链接</a>、<a href="https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html">209.长度最小的子数组 | 代码随想录</a></p><p>关键词：滑动窗口，概念定义</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>暴力法是两层 for 循环。对于一个最小子数组，暴力法每次外层循环确定一个始址，每次内层循环确定一个终址。因此，可以将一个由始址、终址确定的最小子数组，抽象成一个<strong>滑动窗口</strong>。</p><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果</strong>。在暴力法里，滑动窗口“每次从0开始，逐渐变长”，因此时间复杂度O(n^2)；由于只返回长度，空间复杂度O(1)。</p><p>然而，滑动窗口不必用两层 for 循环表示，关键在：窗口长度不需要每次从0开始。代码随想录的图仍然最直观：</p><p><img src="https://file1.kamacoder.com/i/algo/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="滑动窗口移动过程 | 代码随想录"></p><p>每个元素进出滑动窗口各一次，因此时间复杂度O(n)。</p><p>实现滑动窗口，主要确定以下三点：</p><ul><li>窗口内是什么：最小子数组。</li><li>如何移动窗口的起始位置<code>i</code>：长度大于 s 时移动。</li><li>如何移动窗口的结束位置<code>j</code>：无条件移动，结束位置就是遍历数组的指针，即单层 for 循环里的索引。</li></ul><blockquote><p>“滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置，从而将 O(n^2)暴力解法降为 O(n)。”（代码随想录）</p></blockquote><p>最后，注意滑动窗口的区间是左闭右闭。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j, sum=<span class="hljs-number">0</span>, length=INT_MAX;<br>        <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;nums.<span class="hljs-built_in">size</span>(); j++) &#123;     <span class="hljs-comment">// 更新终址j一次</span><br>            sum += nums[j];                 <span class="hljs-comment">// nums[j]入滑动窗口</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;   <br>                <span class="hljs-comment">// 若累加的sum超过阈值，缩小窗口直到sum小于阈值。</span><br>                <span class="hljs-comment">// 为此可能：连续更新始址i多次</span><br>                <span class="hljs-keyword">if</span> (j-i<span class="hljs-number">+1</span> &lt; length) &#123;<br>                    length = j-i<span class="hljs-number">+1</span>;         <span class="hljs-comment">// 更新最小长度</span><br>                &#125;<br>                sum -= nums[i];             <span class="hljs-comment">// nums[i]出滑动窗口</span><br>                i++;                        <span class="hljs-comment">// 更新始址i</span><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span> (length == INT_MAX) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><p>参考：<a href="https://programmercarl.com/kamacoder/0058.%E5%8C%BA%E9%97%B4%E5%92%8C.html">58. 区间和 | 代码随想录</a></p><p>关键词：前缀和，动态规划</p><h4 id="子问题复用"><a href="#子问题复用" class="headerlink" title="子问题复用"></a>子问题复用</h4><p>假设极端情况：查询 m 次，每次查询的范围都是从 0 到 n - 1，则时间复杂度会随 m 一飞冲天。究其原因，是算法需要<strong>频繁对子数组、子矩阵求和</strong>，而每次求和的时间复杂度都是O(n)。</p><p>然而，每次循环重新求和一遍，实际做了很多重复操作。完全可以引入动态规划的思想：先计算出一个子问题结果，然后直接复用，来推导新的结果。</p><p>前缀和正是利用这种<strong>子问题复用</strong>思想，抛弃重复计算，优化区间查询的效率。</p><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p>前缀和的思想：重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。<strong>在涉及计算区间和的问题时非常有用</strong>，可以将查询时间从 O(n) 或 O(n²) 降低到 O(1)。</p><p>要统计 vec[i] 这个数组上的区间和，先累加一个<strong>前缀和数组</strong> p[i]，表示下标 0 到 i 的 vec[i] 累加之和。</p><p><img src="https://file1.kamacoder.com/i/algo/20240627111319.png" alt="使用“前缀和”数组p，统计数组vec区间和"></p><p>如上图所示，要统计 vec 数组下标 2 到下标 5 之间的累加和，用 p[5] - p[1] 即可。</p><p>在构建数组的同时，一次计算好前缀和数组p，后面每次求区间和就只需要 O(1) 的时间开销。</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _CRT_SECURE_NO_WARNINGS    <span class="hljs-comment">// 必须在第一行</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 录入数组大小和元素</span><br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>cin &gt;&gt; nums[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i + <span class="hljs-number">1</span>; j++) &#123;<br>p[i] += nums[j];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 主体逻辑</span><br><span class="hljs-type">int</span> i, j, sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;i, &amp;j) != EOF) &#123;    <span class="hljs-comment">// 大量数据读写，scanf、printf效率高得多。</span><br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) sum = p[j];<br><span class="hljs-keyword">else</span> sum = p[j] - p[i - <span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);<br>sum = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><p>参考：<a href="https://leetcode.cn/problems/reverse-string/">力扣题目链接</a>、<a href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html">344.反转字符串 | 代码随想录</a></p><p>关键词：库函数，双指针法</p><p>字符串基础题目，自己实现库函数reverse。主要明确什么时候不用库函数。</p><ul><li>如果用库函数可以<strong>直接解决</strong>题目关键的部分，建议不要使用；</li><li>如果库函数仅仅是<strong>解题过程中的一小部分</strong>，并且你已经很清楚内部实现原理，可以考虑使用。</li></ul><p>至于实现，是双指针法，逐渐向中间靠拢。时间复杂度为O(n)。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>            i++; j--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a>151. 翻转字符串里的单词</h3><p>参考：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣题目链接</a>、<a href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html">151.翻转字符串里的单词 | 代码随想录</a></p><p>关键词：两次翻转，双指针法，快慢指针，状态机</p><h4 id="两次翻转"><a href="#两次翻转" class="headerlink" title="两次翻转"></a>两次翻转</h4><p>字符串大型综合题。限制S(n)&#x3D;O(1)原地操作，因此重点在两次翻转的思路：**将整个字符串翻转过来，再把各个单词翻过来。**步骤如下：</p><ol><li>去除多余空格；</li><li>翻转整个字符串；</li><li>翻转各个单词。</li></ol><p>三步串行推进，每一步时间复杂度最多O(n)，整体就是O(n)。而第2步<code>reverse()</code>显然是O(n)；第3步每个单词只处理一遍，也是O(n)。主要是第1步不好优化到O(n)。</p><h4 id="双指针与状态机"><a href="#双指针与状态机" class="headerlink" title="双指针与状态机"></a>双指针与状态机</h4><p>第1步内部步骤如下：</p><ol><li>去除开头空格；</li><li>去除中间多余空格；</li><li>截断字符串。</li></ol><p>开头空格好去除，接着思考去除中间多余空格时，怎么用O(n)算法遍历数组。想到<strong>双指针法的共性：一个 for 循环完成两个的数组遍历任务</strong>。又因为要从左往右遍历，想到快慢指针法。</p><p>其中，<strong>快指针要排除的指定元素是“多余空格”</strong>。难点来了：怎么定义“多余空格”？</p><p>代码随想录的算法太复杂，这里借鉴b站评论区的<strong>状态机</strong>思路：</p><blockquote><p>使用一个状态标志<code>need</code>，当<code>fast</code>指向字母时设<code>need = 1</code>，说明需要下一个空格；当<code>fast</code>指向空格时设<code>need = 0</code>，说明不要下一个空格。只有<code>need == 1</code>时才能更新慢指针位置。</p></blockquote><p>快指针到头即遍历完成，此时慢指针要么指向最后一个字母，要么指向该字母后一个空格。分情况截断即可。</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure><hr><h1 id="Day-3-链表基础"><a href="#Day-3-链表基础" class="headerlink" title="Day 3 链表基础"></a>Day 3 链表基础</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Hello World 和 Markdown 语法备忘</title>
    <link href="/2026/01/22/Hexo%20Hello%20World%20%E5%92%8C%20Markdown%20%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98/"/>
    <url>/2026/01/22/Hexo%20Hello%20World%20%E5%92%8C%20Markdown%20%E8%AF%AD%E6%B3%95%E5%A4%87%E5%BF%98/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="常用-Markdown-语法示例"><a href="#常用-Markdown-语法示例" class="headerlink" title="常用 Markdown 语法示例"></a>常用 Markdown 语法示例</h1><h4 id="四号标题"><a href="#四号标题" class="headerlink" title="四号标题"></a>四号标题</h4><p>为了确保自动生成的笔记格式正确，建议从四号标题开始使用。因为一、二、三号标题已在生成的笔记中预留使用。</p><h2 id="标题与分隔线：-n-后换行，n"><a href="#标题与分隔线：-n-后换行，n" class="headerlink" title="标题与分隔线：#*n 后换行，n&lt;3"></a>标题与分隔线：<code>#*n </code>后换行，n&lt;3</h2><p>代码块写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-code">```CPP</span><br><span class="hljs-code">// 多行代码块</span><br><span class="hljs-code">int main() &#123;</span><br><span class="hljs-code">    int a, b;</span><br><span class="hljs-code">&#125;</span><br><span class="hljs-code">`` `  &lt;--去掉空格</span><br></code></pre></td></tr></table></figure><p><code>行内代码</code>：使用反引号&#96;包裹代码片段。</p><p><strong>粗体文字</strong>：在两侧加上 <code>**</code> 或 <code>__</code>。</p><p><em>斜体文字</em>：在两侧加上 <code>*</code> 或 <code>_</code>。</p><p><em><strong>粗斜体文字</strong></em>：在两侧加上 <code>***</code>。</p><ul><li>列表项：在前面加上<code>- </code></li></ul><ol><li>有序列表项：在前面加上<code>1. </code></li></ol><blockquote><p>引用块：在前面加上<code>&gt; </code></p></blockquote><p><a href="https://rsanding.top/">超链接</a>：<code>[]()</code>方括号写字，圆括号放链接。</p><p><img src="https://rsanding.top/img/Man_overworld_retro_tree.gif" alt="There is a man behind the tree.">图片：<code>![]()</code>方括号写字，圆括号放链接。</p><p>表格写法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 表头 1 | 表头 2 |<br>| ------ | ------ |  &lt;--横线多于1个<br>| 内容 1 | 内容 2 |<br>| 内容 3 | 内容 4 |<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
